package org.toradocu.extractor;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.jsoup.Jsoup;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.toradocu.conf.Configuration;
import org.toradocu.doclet.formats.html.ConfigurationImpl;
import org.toradocu.doclet.formats.html.HtmlDocletWriter;
import org.toradocu.doclet.internal.toolkit.taglets.TagletWriter;
import org.toradocu.doclet.internal.toolkit.util.DocFinder;
import org.toradocu.doclet.internal.toolkit.util.DocPath;
import org.toradocu.doclet.internal.toolkit.util.ImplementedMethods;
import org.toradocu.util.OutputPrinter;

import com.sun.javadoc.AnnotationDesc;
import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.ConstructorDoc;
import com.sun.javadoc.Doc;
import com.sun.javadoc.ExecutableMemberDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.Tag;
import com.sun.javadoc.Type;

public final class JavadocExtractor {
	
	/** Holds Javadoc doclet configuration options. */
	private final ConfigurationImpl configuration;
	/** {@code Logger} for this class. */
	private final Logger LOG;

	/**
	 * Constructs a {@code JavadocExtractor} with the given doclet {@code configuration}.
	 * 
	 * @param configuration the Javadoc doclet configuration
	 */
	public JavadocExtractor(ConfigurationImpl configuration) {
		this.configuration = configuration;
		LOG = LoggerFactory.getLogger(JavadocExtractor.class);
	}
	
	/**
	 * Returns a list of {@code DocumentedMethod}s extracted from the given {@code classDoc}.
	 * 
	 * @param classDoc the {@code ClassDoc} from which to extract method documentation
	 * @return a list containing documented methods from the class
	 * @throws IOException if the method encounters an error while reading/generating class documentation
	 */
	public List<DocumentedMethod> extract(ClassDoc classDoc) throws IOException {
		TagletWriter tagletWriter
			= new HtmlDocletWriter(configuration, DocPath.forClass(classDoc)).getTagletWriterInstance(false);
		List<DocumentedMethod> methods = new ArrayList<>();
		
		// Loop on constructors and methods (also inherited) of the target class.
		for (ExecutableMemberDoc member : getConstructorsAndMethods(classDoc)) {
			DocumentedMethod.Builder methodBuilder = new DocumentedMethod.Builder(member.qualifiedName(), getReturnType(member), getParameters(member));
			List<Tag> tags = new ArrayList<>();
			
			// Collect tags in the current method's documentation.
			Collections.addAll(tags, member.tags("@throws"));
			Collections.addAll(tags, member.tags("@exception"));
    		
			// Collect tags that are automatically inherited (i.e., when there is no comment for a method
			// overriding another one).
    		Doc holder = DocFinder.search(new DocFinder.Input(member)).holder;
			Collections.addAll(tags, holder.tags("@throws"));
    		Collections.addAll(tags, holder.tags("@exception"));
    		
			// Collect tags from method definitions in interfaces.
			if (holder instanceof MethodDoc) {
				ImplementedMethods implementedMethods = new ImplementedMethods((MethodDoc) holder, configuration);
				for (MethodDoc implementedMethod : implementedMethods.build()) {
					Collections.addAll(tags, implementedMethod.tags("@throws"));
					Collections.addAll(tags, implementedMethod.tags("@exception"));
				}
			}
			
    		for (Tag tag : tags) {
    			if (!(tag instanceof com.sun.javadoc.ThrowsTag)) {
    				throw new IllegalStateException("This should not happen. Toradocu only considers @throws tags.");
    			}
    			
    			com.sun.javadoc.ThrowsTag throwsTag = (com.sun.javadoc.ThrowsTag) tag;
    			// Handle inline taglets such as {@inheritDoc}.
    			String comment = tagletWriter.commentTagsToOutput(tag, tag.inlineTags()).toString();
    			comment = Jsoup.parse(comment).text(); // Remove HTML tags (also generated by inline taglets).
    			ThrowsTag tagToProcess = new ThrowsTag(getExceptionName(throwsTag), comment);
    			methodBuilder.tag(tagToProcess);
    		}
    
    		methods.add(methodBuilder.build());
		}
	
		printOutput(methods);
		return methods;
	}
	
	/**
	 * Returns all constructors and methods (including inherited ones) from the given {@code ClassDoc}.
	 * 
	 * @param classDoc the {@code ClassDoc} from which to extract constructors and methods
	 * @return a list of {@code ExecutableMemberDoc}s representing the constructors and methods of {@code classDoc}
	 */
	private List<ExecutableMemberDoc> getConstructorsAndMethods(ClassDoc classDoc) {
		List<ExecutableMemberDoc> membersToAnalyze = new ArrayList<>();
		Set<String> membersAlreadyConsidered = new HashSet<>();
		ClassDoc currentClass = classDoc; // Used to traverse over superclasses.
		
		// Add non-default constructors.
		for (ConstructorDoc constructor : currentClass.constructors()) {
			// This is a bad workaround to bug in Doc.position() method. It does not return null
			// for default constructors. It instead returns the line number of the start of the class.
			if (constructor.position() == null
				|| !constructor.position().toString().equals(currentClass.position().toString())) {
				membersToAnalyze.add(constructor);
			}
		}
		// Add non-synthetic methods (i.e. those methods that have not been synthesized by the compiler).
		do {
			List<ExecutableMemberDoc> currentMembers = new ArrayList<>();
			currentMembers.addAll(Arrays.asList(currentClass.methods()));
			// Class hierarchy is traversed from from subclass to superclass. Each visited method's signature
			// is stored so that a method is considered only once, even when it is overridden.
			for (ExecutableMemberDoc member : currentMembers) {
				String memberID = member.name() + member.signature();
				if (!membersAlreadyConsidered.contains(memberID)) {
					if (!member.isSynthetic()) { // Ignore synthetic methods.
						membersToAnalyze.add(member);
					}
					membersAlreadyConsidered.add(memberID);
				}
			}
			currentClass = currentClass.superclass();
		} while (currentClass != null && !currentClass.qualifiedName().equals("java.lang.Object"));
		return membersToAnalyze;
	}
	
	/**
	 * Returns the fully qualified return type of the given constructor or method, including the dimension
	 * of the return type if it's an array. The returned string is the empty string if this is a constructor.
	 * 
	 * @param member the executable member (constructor or method) to return the return type of as a string
	 * @return the return type of the given member or the empty string if the member is a constructor
	 */
	private String getReturnType(ExecutableMemberDoc member) {
		if (member instanceof MethodDoc) {
			MethodDoc method = (MethodDoc) member;
			return method.returnType().qualifiedTypeName() + method.returnType().dimension();
		} else {
			return "";
		}
	}
	
	/**
	 * Returns an array of {@code Parameter}s from the documentation for the given constructor or method.
	 * 
	 * @param member the constructor or method from which to extract parameters
	 * @return an array of parameters
	 */
	private Parameter[] getParameters(ExecutableMemberDoc member) {
		com.sun.javadoc.Parameter[] params = member.parameters();
		Parameter[] parameters = new Parameter[params.length];
		for (int i = 0; i < parameters.length; i++) {
			Type pType = params[i].type();
			String type = pType.qualifiedTypeName() + pType.dimension();
			// Determine nullness constraints from parameter annotations.
			Boolean nullable = null;
			for (AnnotationDesc annotation : params[i].annotations()) {
				if (annotation.annotationType().name().equalsIgnoreCase("nullable")) {
					nullable = true;
					break;
				} else if (annotation.annotationType().name().equalsIgnoreCase("notnull")
						   || annotation.annotationType().name().equalsIgnoreCase("nonnull")) {
					nullable = false;
					break;
				}
			}
			// Set type of last parameter to varargs if necessary.
			if (member.isVarArgs() && i == parameters.length - 1) {
				type = pType.qualifiedTypeName() + "...";
			}
			parameters[i] = new Parameter(type, params[i].name(), i, nullable);
		}
		return parameters;
	}

	/**
	 * Prints the given list of {@code DocumentedMethod}s to the configured Javadoc extractor output file.
	 * 
	 * @param methods the methods to print
	 */
	private void printOutput(List<DocumentedMethod> methods) {
		OutputPrinter.Builder builder = new OutputPrinter.Builder("JavadocExtractor", methods);
		OutputPrinter printer = builder.file(Configuration.INSTANCE.getJavadocExtractorOutput()).logger(LOG).build();
		printer.print();
	}
	
	/**
	 * This method tries to return the qualified name of the exception in the {@code throwsTag}.
	 * If the source code of the exception is not available, then just the simple name in the Javadoc
	 * comment is returned.
	 * 
	 * @param throwsTag throws tag to extract exception name from
	 * @return the name of the exception in the throws tag (qualified, if possible)
	 */
	private String getExceptionName(com.sun.javadoc.ThrowsTag throwsTag) {
		Type exceptionType = throwsTag.exceptionType();
		return exceptionType != null ? exceptionType.qualifiedTypeName() : throwsTag.exceptionName();
	}

}
